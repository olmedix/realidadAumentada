<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>WebXR AR + Cubo 3D</title>
<style>
  html,body{margin:0;height:100%;background:#000}
  #btn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
       padding:12px 16px;font:600 16px system-ui;border:0;border-radius:10px;
       background:#0ea5e9;color:#fff;box-shadow:0 10px 28px rgba(0,0,0,.25);cursor:pointer;z-index:10}
  #log{position:fixed;left:0;right:0;bottom:0;max-height:40vh;overflow:auto;
       background:rgba(0,0,0,.7);color:#0ff;font:12px ui-monospace,monospace;padding:.5rem;z-index:10}
</style>
</head>
<body>
<button id="btn">Iniciar AR</button>
<pre id="log"></pre>
<script>
const $ = s => document.querySelector(s);
const log = (...m)=>{$('#log').textContent += m.join(' ') + '\n';};

// ======== GL & XR state ========
let gl, program;
let xrSession, refSpace, viewerSpace, hitTestSource;
let currentHitPose = null;   // pose del retículo (sigue el plano)
let placedPose     = null;   // pose anclada al tocar

// ======== Shaders (MVP + color) ========
const VS = `
  attribute vec3 pos;
  uniform mat4 u_mvp;
  void main(){
    gl_Position = u_mvp * vec4(pos,1.0);
  }
`;
const FS = `
  precision mediump float;
  uniform vec4 u_color;
  void main(){ gl_FragColor = u_color; }
`;

// ======== Geometrías ========
// Retículo: cuadrado plano en el plano XZ (dos triángulos)
const quadVerts = new Float32Array([
  -0.15, 0.0, -0.15,
   0.15, 0.0, -0.15,
   0.15, 0.0,  0.15,
  -0.15, 0.0, -0.15,
   0.15, 0.0,  0.15,
  -0.15, 0.0,  0.15
]);

// Cubo: lado 0.2 m (20 cm) centrado en origen (12 triángulos)
const s = 0.1; // mitad del lado (0.2/2)
const cubeVerts = new Float32Array([
  //       X      Y      Z
  -s, -s,  s,  s, -s,  s,  s,  s,  s, -s,  s,  s,   // +Z (frente)
  -s, -s, -s, -s,  s, -s,  s,  s, -s,  s, -s, -s,   // -Z (detrás)
  -s,  s, -s, -s,  s,  s,  s,  s,  s,  s,  s, -s,   // +Y (arriba)
  -s, -s, -s,  s, -s, -s,  s, -s,  s, -s, -s,  s,   // -Y (abajo)
   s, -s, -s,  s,  s, -s,  s,  s,  s,  s, -s,  s,   // +X (derecha)
  -s, -s, -s, -s, -s,  s, -s,  s,  s, -s,  s, -s    // -X (izquierda)
]);
const cubeIndices = new Uint16Array([
  0,1,2,  0,2,3,      // frente
  4,5,6,  4,6,7,      // detrás
  8,9,10, 8,10,11,    // arriba
 12,13,14, 12,14,15,  // abajo
 16,17,18, 16,18,19,  // derecha
 20,21,22, 20,22,23   // izquierda
]);

// ======== Matrices util ========
function matMul(a,b){ // 4x4 * 4x4
  const r = new Float32Array(16);
  for (let i=0;i<4;i++){
    for (let j=0;j<4;j++){
      r[i*4+j] =
        a[i*4+0]*b[0*4+j] +
        a[i*4+1]*b[1*4+j] +
        a[i*4+2]*b[2*4+j] +
        a[i*4+3]*b[3*4+j];
    }
  }
  return r;
}
function matIdentity(){ const m=new Float32Array(16); m[0]=m[5]=m[10]=m[15]=1; return m; }
function matScale(x,y,z){ const m=matIdentity(); m[0]=x; m[5]=y; m[10]=z; return m; }
function matTranslate(x,y,z){ const m=matIdentity(); m[12]=x; m[13]=y; m[14]=z; return m; }

// ======== GL helpers ========
function createProgram(gl, vsSrc, fsSrc){
  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(sh));
    }
    return sh;
  }
  const vs = compile(gl.VERTEX_SHADER, vsSrc);
  const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    throw new Error(gl.getProgramInfoLog(prog));
  }
  return prog;
}

let posLoc, u_mvp, u_color, quadVbo, cubeVbo, cubeIbo;

function initGL(){
  if (gl) return;
  const canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  gl = canvas.getContext('webgl', {alpha:true, antialias:true});
  const onResize = ()=>{ canvas.width = innerWidth; canvas.height = innerHeight; };
  addEventListener('resize', onResize); onResize();

  program = createProgram(gl, VS, FS);
  posLoc  = gl.getAttribLocation(program, 'pos');
  u_mvp   = gl.getUniformLocation(program, 'u_mvp');
  u_color = gl.getUniformLocation(program, 'u_color');

  quadVbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVbo);
  gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

  cubeVbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVbo);
  gl.bufferData(gl.ARRAY_BUFFER, cubeVerts, gl.STATIC_DRAW);

  cubeIbo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIbo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);
}

// ======== XR flow ========
async function startAR(){
  if (!('xr' in navigator)) { alert('navigator.xr no disponible'); return; }
  const supported = await navigator.xr.isSessionSupported('immersive-ar');
  log('immersive-ar soportado:', supported);
  if (!supported) { alert('Este navegador no soporta AR'); return; }

  xrSession = await navigator.xr.requestSession('immersive-ar', {
    optionalFeatures: ['local-floor','hit-test'] // hit-test opcional
  });

  initGL();
  await gl.makeXRCompatible?.();
  xrSession.updateRenderState({ baseLayer: new XRWebGLLayer(xrSession, gl) });

  refSpace    = await xrSession.requestReferenceSpace('local');
  viewerSpace = await xrSession.requestReferenceSpace('viewer');

  hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

  // Tap para anclar el cubo 3D
  xrSession.addEventListener('select', ()=>{
    if (currentHitPose){
      // Guardamos la pose del plano y elevamos media altura del cubo (s) para que no “se hunda”
      const base = currentHitPose.transform.matrix;
      const lift = matTranslate(0, s, 0);
      placedPose = { matrix: matMul(base, lift) };
    }
  });

  $('#btn').style.display = 'none';
  xrSession.addEventListener('end', ()=>{ $('#btn').style.display='block'; log('Sesión terminada'); });
  xrSession.requestAnimationFrame(onXRFrame);
}

function onXRFrame(t, frame){
  const session = frame.session;
  session.requestAnimationFrame(onXRFrame);

  const pose = frame.getViewerPose(refSpace);
  if (!pose) return;

  // Actualizamos retículo
  currentHitPose = null;
  if (hitTestSource){
    const hits = frame.getHitTestResults(hitTestSource);
    if (hits.length){
      currentHitPose = hits[0].getPose(refSpace);
    }
  }

  const glLayer = session.renderState.baseLayer;
  gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
  gl.clearColor(0,0,0,0); // alpha 0 → cámara visible
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  gl.useProgram(program);
  gl.enableVertexAttribArray(posLoc);

  for (const view of pose.views){
    const vp = glLayer.getViewport(view);
    gl.viewport(vp.x, vp.y, vp.width, vp.height);

    const proj = view.projectionMatrix;
    const viewInv = view.transform.inverse.matrix;

    // 1) Retículo (gris) pegado al plano
    if (currentHitPose){
      const model = currentHitPose.transform.matrix;
      const mvp   = matMul(proj, matMul(viewInv, model));
      gl.bindBuffer(gl.ARRAY_BUFFER, quadVbo);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
      gl.uniformMatrix4fv(u_mvp, false, mvp);
      gl.uniform4f(u_color, 0.6, 0.6, 0.6, 0.8);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    // 2) Cubo 3D (naranja) en la pose anclada
    if (placedPose){
      // Model = placedPose * (escala opcional 1x)  (ya lo elevamos medio cubo en el select)
      const model = placedPose.matrix;
      const mvp   = matMul(proj, matMul(viewInv, model));
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVbo);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIbo);
      gl.uniformMatrix4fv(u_mvp, false, mvp);
      gl.uniform4f(u_color, 1.0, 0.42, 0.0, 0.95); // naranja
      gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);
    }
  }
}

// ======== UI ========
$('#btn').addEventListener('click', startAR);
log('HTTPS:', location.protocol === 'https:');
log('UserAgent:', navigator.userAgent);
</script>
</body>
</html>
