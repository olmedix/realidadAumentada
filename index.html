<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>WebXR AR + Hit Test (mínimo)</title>
<style>
  html,body{margin:0;height:100%;background:#000}
  #btn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
       padding:12px 16px;font:600 16px system-ui;border:0;border-radius:10px;
       background:#0ea5e9;color:#fff;box-shadow:0 10px 28px rgba(0,0,0,.25);cursor:pointer;z-index:10}
  #log{position:fixed;left:0;right:0;bottom:0;max-height:40vh;overflow:auto;
       background:rgba(0,0,0,.7);color:#0ff;font:12px ui-monospace,monospace;padding:.5rem;z-index:10}
</style>
</head>
<body>
<button id="btn">Iniciar AR</button>
<pre id="log"></pre>
<script>
const $ = s => document.querySelector(s);
const log = (...m)=>{$('#log').textContent += m.join(' ') + '\n';};

// ======== GL & XR state ========
let gl, program;
let xrSession, refSpace, viewerSpace, hitTestSource;
let currentHitPose = null;   // pose del retículo (sigue el plano)
let placedPose     = null;   // pose anclada al tocar

// ======== Minimal shader (dibujar cuadrado) ========
const VS = `
  attribute vec3 pos;
  uniform mat4 u_mvp;
  void main(){
    gl_Position = u_mvp * vec4(pos,1.0);
  }
`;
const FS = `
  precision mediump float;
  uniform vec4 u_color;
  void main(){ gl_FragColor = u_color; }
`;

// Un cuadrado (dos triángulos) en el plano XZ, centrado en el origen
const quadVerts = new Float32Array([
  -0.15, 0.0, -0.15,
   0.15, 0.0, -0.15,
   0.15, 0.0,  0.15,
  -0.15, 0.0, -0.15,
   0.15, 0.0,  0.15,
  -0.15, 0.0,  0.15
]);

// ======== Matrices util ========
function matMul(a,b){ // 4x4 * 4x4
  const r = new Float32Array(16);
  for (let i=0;i<4;i++){
    for (let j=0;j<4;j++){
      r[i*4+j] =
        a[i*4+0]*b[0*4+j] +
        a[i*4+1]*b[1*4+j] +
        a[i*4+2]*b[2*4+j] +
        a[i*4+3]*b[3*4+j];
    }
  }
  return r;
}
function matIdentity(){
  const m = new Float32Array(16);
  m[0]=m[5]=m[10]=m[15]=1;
  return m;
}
function matScale(sx,sy,sz){
  const m = matIdentity();
  m[0]=sx; m[5]=sy; m[10]=sz;
  return m;
}

// ======== GL helpers ========
function createProgram(gl, vsSrc, fsSrc){
  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(sh));
    }
    return sh;
  }
  const vs = compile(gl.VERTEX_SHADER, vsSrc);
  const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    throw new Error(gl.getProgramInfoLog(prog));
  }
  return prog;
}

let posLoc, u_mvp, u_color, vbo;

function initGL(){
  if (gl) return;
  const canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  gl = canvas.getContext('webgl', {alpha:true, antialias:true});
  const onResize = ()=>{ canvas.width = innerWidth; canvas.height = innerHeight; };
  addEventListener('resize', onResize); onResize();

  program = createProgram(gl, VS, FS);
  posLoc  = gl.getAttribLocation(program, 'pos');
  u_mvp   = gl.getUniformLocation(program, 'u_mvp');
  u_color = gl.getUniformLocation(program, 'u_color');

  vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
}

// ======== XR flow ========
async function startAR(){
  if (!('xr' in navigator)) { alert('navigator.xr no disponible'); return; }
  const supported = await navigator.xr.isSessionSupported('immersive-ar');
  log('immersive-ar soportado:', supported);
  if (!supported) { alert('Este navegador no soporta AR'); return; }

  xrSession = await navigator.xr.requestSession('immersive-ar', {
    optionalFeatures: ['local-floor','hit-test'] // hit-test opcional (no bloquea sesión)
  });

  initGL();
  await gl.makeXRCompatible?.();
  xrSession.updateRenderState({ baseLayer: new XRWebGLLayer(xrSession, gl) });

  // Referencias necesarias
  refSpace    = await xrSession.requestReferenceSpace('local');
  viewerSpace = await xrSession.requestReferenceSpace('viewer');

  // Fuente de hit-test (rayo desde la vista del usuario)
  hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

  // "Tap" para colocar
  xrSession.addEventListener('select', ()=>{
    if (currentHitPose){
      // Guardamos la pose actual como colocada
      placedPose = {
        matrix: currentHitPose.transform.matrix.slice()
      };
    }
  });

  $('#btn').style.display = 'none';
  xrSession.addEventListener('end', ()=>{ $('#btn').style.display='block'; log('Sesión terminada'); });
  xrSession.requestAnimationFrame(onXRFrame);
}

function onXRFrame(t, frame){
  const session = frame.session;
  session.requestAnimationFrame(onXRFrame);

  const pose = frame.getViewerPose(refSpace);
  if (!pose) return;

  // Intentamos hacer hit test (si está disponible)
  currentHitPose = null;
  if (hitTestSource){
    const hits = frame.getHitTestResults(hitTestSource);
    if (hits.length){
      currentHitPose = hits[0].getPose(refSpace);
    }
  }

  const glLayer = session.renderState.baseLayer;
  gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
  gl.clearColor(0,0,0,0); // alpha 0 → se ve el mundo real
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  gl.useProgram(program);
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

  for (const view of pose.views){
    const vp = glLayer.getViewport(view);
    gl.viewport(vp.x, vp.y, vp.width, vp.height);

    // Matrices de la vista
    const proj = view.projectionMatrix;
    const viewInv = view.transform.inverse.matrix;

    // 1) Dibujar retículo (gris) si hay hit
    if (currentHitPose){
      const model = currentHitPose.transform.matrix; // ya orientado al plano
      const scale = matScale(1.0, 1.0, 1.0);         // tamaño del retículo (ajusta si quieres)
      const mvp   = matMul(proj, matMul(viewInv, matMul(model, scale)));
      gl.uniformMatrix4fv(u_mvp, false, mvp);
      gl.uniform4f(u_color, 0.6, 0.6, 0.6, 0.8);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    // 2) Dibujar "cubo plano" colocado (naranja) si ya tocaste
    if (placedPose){
      const model = placedPose.matrix;
      const scale = matScale(1.0, 1.0, 1.0);
      const mvp   = matMul(proj, matMul(viewInv, matMul(model, scale)));
      gl.uniformMatrix4fv(u_mvp, false, mvp);
      gl.uniform4f(u_color, 1.0, 0.42, 0.0, 0.9); // naranja
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
  }
}

// ======== UI ========
$('#btn').addEventListener('click', startAR);
log('HTTPS:', location.protocol === 'https:');
log('UserAgent:', navigator.userAgent);
</script>
</body>
</html>
